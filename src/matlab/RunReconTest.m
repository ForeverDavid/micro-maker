% This script is the main driver for the microstructure reconstruciton
% code. It defines the parameters of the reconstruction, sets up the
% reconstruction objects\data sctructures, runs its, and cleans up.
%
%
% Author: David Turner
% email: davidt0x@gmail.com
% December 2016

%------------- BEGIN CODE --------------

% Define number of levels on which we will perform this reconstruction.
% Each level is generated by upsampling the result of the reconstruction to
% twice its size. Three is usually a good number but sometimes high
% frequency (small features) can be lost and not recovered from the
% exemplars when they are downsampled too much. Converesely,
% reconsutrctions might become intractable if you do not start and a small
% enough size since early levels take many iterations to converge.
recon_params.NUM_LEVELS = 3;

% The neighborhood sizes to use. This is the size in pixels of the square
% neighborhood. Each element of this vector specifies the neighborhood size
% for a level in the reconstruction. The number of elements must be either
% NUM_LEVELS or simply a scalar, in which case the same neighborhoods size
% will be used for each level. The order of the levels is from lowest
% resolution to highest. Smaller neighborhoods size should be used at
% higher resolutions if reconstructions are too slow. 
recon_params.NB_SIZES = [9 9 5];

% The final dimensions of the reconstruction.
recon_params.FULL_RECON_SIZE = [100 100 100];

% A cell array containing a single image (2D matrix of grayscale values
% ranging between 0 and 1) for each element. These are the exemplar images
% to use for the reconstructions. The orientations (within the
% reconstruction) for these exemplars is defined by NB_INDICES. Each
% element of this cell array can also be a cell array as well. In this
% case, the internal cell arrays contain the gaussian pyramid of each
% exemplar. There should be NUM_LEVELS images in each cell array. The order
% for the images should be from lowest resolution to highest. 

% Load an a set of images.
load('../../data/tubes_exemplars.mat');  
recon_params.EXEMPLARS = E(1:3);

% Currently, this code supports up to nine different exemplar image
% orientations which are defined by the miller indices (0 0 1), (0 1 0),
% (1 0 0), (1 1 0), (-1 1 0), (0 1 1), (0 -1 1), (1 0 1), and (-1 0 1). 
% Consult, the code in MakeNBOffsets to understand more. NB_INDICES
% defines, for each element of EXEMPLARS, which orientation the exemplar
% has within reconstruction sample frame. Each element of NB_INDICES is an
% index into the above list of nine orientations. 
recon_params.NB_INDICES = 1:3;

% The number of processor cores that the code can use.
recon_params.NUM_CORES = 4;

% Lets use PatchTable for our nearest neighbor computations, its is faster.
recon_params.ANN_ALGO = 'FLANN';

% Turn on neighborhood weigthing.
recon_params.UseNeighborhoodSearchWeights = true;

% Lets setup the reconstruction object. This may take a bit.
ReconH = SetupReconMultiRes(recon_params);

% Run the reconstruction
[S_star, Recon] = Reconstruct(ReconH, [2, 10, 20]);

% Cleanup all the memory allocated 
DestroyReconMultiRes(Recon);
