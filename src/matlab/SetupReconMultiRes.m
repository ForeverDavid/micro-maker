function ReconH = SetupReconMultiRes(params)
% SetupReconMultiRes - Function to create data structures needed to compute a
% 3D microstructure reconstruction from exemplar 2D data in a
% multiresolution manner.
% 
% This function is the first step in computing a 3D reconstruction of a
% microstructure given data collected on 2D sections. Its basic purpose is
% to create a reconstruction struct that contains all of the precomputed 
% data structures nescessary to effientltly perform the optimization. This
% is the multi-resolution analog to the function SetupRecon. Were
% SetupRecon creates a struct for perfomring the reconstruction
% optimization at a single resolution, SetupReconMultiRes sets up a
% hierarchy (gaussian pyramid, scale space) reconstructions objects by
% downsampling the exemplar images. This allows for more efficient
% reconstruction of large 3D images because coarse grain features can be
% built up at low resolution reconstructions and then feed into the next
% level reconstruction to be refined. This also allows us to keep small
% neighborhoods but still capture feature scales larger than the
% neighborhood size at the highest resolution.
%
% This object can be passed to the Reconstruct function to perform this 
% optimization.
%
% Syntax:  [ReconH] = SetupReconMultiRes(params)
%
% Inputs:
%    params - This argument is a struct containing all of the parameters of
%    the reconstruction. The bare minimum of parameters are as follows:
%   
%       params.NUM_LEVELS:
%           Define number of levels on which we will perform this reconstruction.
%           Each level is generated by upsampling the result of the reconstruction to
%           twice its size. Three is usually a good number but sometimes high
%           frequency (small features) can be lost and not recovered from the
%           exemplars when they are downsampled too much. Converesely,
%           reconsutrctions might become intractable if you do not start and a small
%           enough size since early levels take many iterations to converge.
%
%       params.NB_SIZES: 
%           The neighborhood sizes to use. This is the size in pixels of the square
%           neighborhood. Each element of this vector specifies the neighborhood size
%           for a level in the reconstruction. The number of elements must be either
%           NUM_LEVELS or simply a scalar, in which case the same neighborhoods size
%           will be used for each level. The order of the levels is from lowest
%           resolution to highest. Smaller neighborhoods size should be used at
%           higher resolutions if reconstructions are too slow. 
%
%       params.FULL_RECON_SIZE: 
%           The final dimensions of the reconstruction.
%
%       params.EXEMPLARS:
%           A cell array containing a single image (2D matrix of grayscale values
%           ranging between 0 and 1) for each element. These are the exemplar images
%           to use for the reconstructions. The orientations (within the
%           reconstruction) for these exemplars is defined by NB_INDICES. Each
%           element of this cell array can also be a cell array as well. In this
%           case, the internal cell arrays contain the gaussian pyramid of each
%           exemplar. There should be NUM_LEVELS images in each cell array. The order
%           for the images should be from lowest resolution to highest.
%
%       params.NB_INDICES:  
%           Currently, this code supports up to nine different exemplar image
%           orientations which are defined by the miller indices (0 0 1), (0 1 0),
%           (1 0 0), (1 1 0), (-1 1 0), (0 1 1), (0 -1 1), (1 0 1), and (-1 0 1). 
%           Consult, the code in MakeNBOffsets to understand more. NB_INDICES
%           defines, for each element of EXEMPLARS, which orientation the exemplar
%           has within reconstruction sample frame. Each element of NB_INDICES is an
%           index into the above list of nine orientations. 
%
%       params.NUM_CORES:  
%           The number of processor cores that the code can use.
%
%       params.ANN_ALGO
%           The approximate nearest neighbor algorithm to use. Either
%           'FLANN' or 'PatchTable'.
%
%       params.UseNeighborhoodSearchWeights
%           Whether to use the neighborhood weigthing scheme that tries to
%           promote diverse use of neughborhhods by downweighting overused
%           neighborhoods. By default we don't use this because it
%           increases search times (neighborhood search tables need to be
%           rebuilt) but it can help if you find the solution is getting
%           stuck in a local minimum by oversampling the same
%           neighborhoods.
%
% Outputs:
%    ReconH - A struct containing all the data structures needed
%    for generating reconstructions with the specified parameters. Can be
%    used multiple times as an argument to the Reconstruct function.
%
% Example: 
%    ReconH = SetupReconMultiRes(recon_params);
%
% Other m-files required: SetupRecon.m CheckReconParams.m MakeNBOffsets.m
% BuildExemplarPyramid.m add_paths.m
%
% See also: SetupRecon DestroyReconMultiRes RunReconTest

% Author: David Turner
% Email: davidt0x@gmail.com
% Website: https://github.com/davidt0x
% December 2016; 

%------------- BEGIN CODE --------------

% Lets do a quick sanity check on all the parameters the user has passed
% for this reconstruction.
[isValid, errMsg] = CheckReconParamsMultiRes(params);
if(~isValid)
    error(errMsg);
end

% Lets copy the parameter to the output struct.
ReconH = params;

% The recon object contains a hierarchy of sub-recon structs, one for each
% level of the reconstruction. Lets set these up.
ReconH.ReconObjects = cell(params.NUM_LEVELS, 1);

% If the cell array has cell arrays in it, assume the user has passed in
% all the downsampled images so we don't have to compute them. This allows
% the user to construct their own downsampling algorithm if they want.
ReconH.NUM_EXEMPLARS = length(ReconH.EXEMPLARS);
if(iscell(ReconH.EXEMPLARS{1}))
    P = ReconH.EXEMPLARS;
    NUM_LEVELS = length(P{1});
    ReconH.ReconObjects = cell(NUM_LEVELS, 1);
else
    P = cell(ReconH.NUM_EXEMPLARS, 1);
    for ii=1:ReconH.NUM_EXEMPLARS
        P{ii} = BuildExemplarPyramid(ReconH.EXEMPLARS{ii});
    end
end

RECON_SIZE = params.FULL_RECON_SIZE;

% For each level in our reconstruction, we need to create a set of data
% structures for performing the optimization at that level. These data
% structures are use for keeping track of the current iteration, querying
% exemplar images for nearest neighborhoods, etc.
for level=1:ReconH.NUM_LEVELS
    fprintf(1, 'Level %d\n', level);
    
    % Get the exemplars for this resolution.
    Exyz = cell(ReconH.NUM_EXEMPLARS,1);
    for ex=1:ReconH.NUM_EXEMPLARS
        Exyz{ex} = P{ex}{level};
    end
    
    % If no number of cores is specified, just use one.
    if(~isfield(params, 'NUM_CORES'))
        rparams.NUM_CORES = 1;
    else
        rparams.NUM_CORES = params.NUM_CORES;
    end
    
    rparams.NB_SIZE = params.NB_SIZES(level);
    rparams.NB_INDICES = params.NB_INDICES;
    rparams.RECON_SIZE = RECON_SIZE;
    rparams.EXEMPLARS = Exyz;
    
    if(isfield(params, 'ANN_ALGO'))
        rparams.ANN_ALGO = params.ANN_ALGO;
    end
    
    if(isfield(params, 'UseNeighborhoodSearchWeights'))
        rparams.UseNeighborhoodSearchWeights = params.UseNeighborhoodSearchWeights;
    end
    
    ReconH.ReconObjects{level} = SetupRecon(rparams);
    
    % Reduce the size of the reconstruction by half.
    RECON_SIZE = ceil(RECON_SIZE / 2);
end
